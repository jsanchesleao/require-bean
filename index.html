<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Require Bean Documentation">
    <meta name="author" content="jsanchesleao">

    <title>Require Bean</title>

    <!-- Bootstrap core CSS -->
    <link href="http://netdna.bootstrapcdn.com/bootstrap/3.1.1/css/bootstrap.min.css" rel="stylesheet">
    <link href="http://netdna.bootstrapcdn.com/bootswatch/3.1.1/cerulean/bootstrap.min.css" rel="stylesheet">


    <!-- Add custom CSS here -->
    <link href="css/simple-sidebar.css" rel="stylesheet">
    <link href="http://netdna.bootstrapcdn.com/font-awesome/4.0.3/css/font-awesome.min.css" rel="stylesheet">

</head>

<body>

    <div id="wrapper">

        <!-- Sidebar -->
        <div id="sidebar-wrapper">
            <ul class="sidebar-nav">
                <li class="sidebar-brand"><a href="#">Require Bean</a>
                </li>
                <li><a href="#quickstart">Quickstart</a>
                </li>
                <li><a href="#installation">Installation</a>
                </li>
                <li><a href="#bean-notation">Bean Notation</a>
                </li>
                <li><a href="#asynchronous-beans">Asynchronous Beans</a>
                </li>
                <li><a href="#dependency-management">Dependency Management</a>
                </li>
                <li><a href="#bean-scope">Bean Scope</a>
                </li>
                <li><a href="#circular-dependencies">Circular Dependencies</a>
                </li>
                <li><a href="#multiple-containers">Multiple Containers</a>
                </li>
                <li><a href="#interceptors">Interceptors</a>
                </li>
            </ul>
        </div>

        <!-- Page content -->
        <div id="page-content-wrapper">
            <div class="content-header">
                <h1>
                    <a id="menu-toggle" href="#" class="btn btn-default"><i class="icon-reorder"></i></a>
                    Require Bean
                </h1>
            </div>
            <!-- Keep all page content within the page-content inset div! -->
            <div class="page-content inset">
                <div class="row">
                    <div class="col-md-12">
                        <section id="intro">
                            <p class="lead">
                                Minimal IoC container, designed for simplicity.
                            </p>
                            <p>
                                It's main concept is the container, in which the beans are registered.
                                A bean is just a function that returns a value, like the following:</p>
                            <pre class="prettyprint">var mybean = function(){
    return {
        value: 'something'
        //anything here
    }
}</pre>
                        </section>
                        <section id="installation">
                            <h1>Installation</h1>
                            <pre>npm install require-bean</pre>
                        </section>
                        <section id="quickstart">
                            <h1>Quickstart</h1>
                            <p>Follow the commented example:</p>
                            <pre class="prettyprint">
/*
    Instantiate the container
    This line creates a container named 'myapp', to hold beans related to 'myapp' application
*/
var app = require('require-bean').container('myapp');

/*Define a bean that takes no dependency*/
var logger = function(){
    return {
        info: function(x){
            console.log(x)
        }
    }
}

/*
    Define a bean that depends on logger
    The dependency is passed as an argument to the bean function
*/
var greeter = function(logger){
    return function(){
        logger.info("Hello World")
    }
}

/*Register the beans*/
app.register('logger', logger);
app.register('greeter', greeter);

/*Require a wired bean from the container*/
app.run(function(greeter){
    greeter(); //This instance will run with the 'logger' dependency properly wired
});</pre>
                            <p>
                                There is also a helper method to register other modules into the container:
                            </p>
                            <pre class="prettyprint">app.register_module('fs');</pre>
                            <p>
                                This will register the module with the same name into the container as a dependency for other beans.
                                If the module's name contains hyphens or dots, it will be converted to a camelCase name:
                            </p>
                            <pre class="prettyprint">app.register_module('token-manager'); //this will register a bean named tokenManager to hold the module.</pre>
                        </section>

                        <section id="bean-notation">
                            <h1>Bean Notation</h1>
                            <p>
                                Alternatively, and preferably, you can use bean notation to register your beans.
                                For that you should use the method <code>app.bean()</code> like the following:
                            </p>
                            <pre class="prettyprint">var beanDef = {
   name: 'myBean',
   dependencies: ['aDependency', 'otherDependency'],
   scope: app.SINGLETON,
   factory: function(a, b){
      return "my awesome beans using " + a + " and " + b;
   }
}
//This registers a bean named 'myBean', with two named dependencies ('aDependency' and 'otherDependency') and singleton scope
app.bean(beanDef);</pre>
                            <p>
                                If you pass a dependencies array to the definition, the names of the factory function arguments will be ignored,
                                and the names in the array will be used, in the proper order.
                                If you omit the dependencies array or pass <code>app.RESOLVE</code>,
                                the names of the arguments of factory function will be used.
                            </p>
                            <p>
                                This strict way to define a bean will accept an object with four fields:
                            </p>
                            <ul>
                                <li>name
                                    <p>
                                        Required. This will be the name to be saved in the registry.
                                    </p>
                                </li>
                                <li>dependencies
                                    <p>
                                        Optional. An array containing the names of the dependencies to be passed to factory.
                                        If instead you pass the constant <code>app.RESOLVE</code>,
                                        the container will infer from the names of the factory arguments<br>
                                        Default: <code>app.RESOLVE</code>
                                    </p>
                                </li>
                                <li>scope
                                    <p>
                                        Optional. You can pass <code>container.SINGLETON</code> or <code>app.PROTOTYPE</code>,
                                        so that your bean will be placed correctly in the registry.<br>
                                        Default: <code>app.SINGLETON</code>
                                    </p>
                                </li>
                                <li>factory
                                    <p>Required. The function that will return your bean. It will take the dependencies as arguments,
                                        and they will be resolved based on the dependencies parameter defined earlier.
                                    </p>
                                </li>
                            </ul>
                            <p>
                                If you write all beans in bean notation, there is a shortcut to register them all, so you can
                                register all beans inside a directory at once:
                            </p>
                            <pre class="prettyprint">var app = require('require-bean').container('myapp');

app.bean({ dir: __dirname +'/lib'}); //registers all beans inside lib directory</pre>
                        </section>

                        <section id="asynchronous-beans">
                            <h1>Asynchronous Beans</h1>
                            <p>
                                If your bean creation should be asynchronous, like registering a running http server,
                                you need to wire the special dependency <code>$return</code>, provided out of the box:
                            </p>
                            <pre class="prettyprint">    app.register('server', function(http, $return){ //
        var server = http.createServer();
        server.listen(8000, function(){
            $return(server);  // registers the server asynchronously;
        });
    });</pre>
                        </section>

                        <section id="dependency-management">
                            <h1>Dependency Management</h1>
                            <p>
                                Since the beans are functions that return values, the dependencies are managed as these functions' arguments.
                                <b>require-bean</b> will look in the named parameters for dependencies,
                                so if you have a bean named <i>awesomebean</i> and need it as a dependency, you could write this:
                            </p>
                            <pre class="prettyprint">app.register('mybean', function(awesomebean){ /* cool stuff here */ })</pre>
                            <p>
                                In order to do the correct wiring, the argument <i>name</i> must match the bean name.
                                If no bean with that name have been registered, an exception will be thrown.
                            </p>
                            <p>
                                There is no restriction for the name of the beans you want to register,
                                but they will be useless if you cannot define a function argument with the same name.
                            </p>
                            <p>
                                If the bean was defined in Bean Notation, the dependencies will be resolved differently,
                                by first looking at the dependencies array provided, and using the function arguments as a fallback.
                            </p>
                        </section>
                        <section id="bean-scope">
                            <h1>Bean Scope</h1>
                            <p>When you register a bean, you can choose one of these methods:</p>

                            <ul>
                                <li>app.register( bean_name, bean_function )
                                    <p>
                                        This method registers the bean as a singleton, meaning that every time you request it,
                                        the same instance will be returned to you
                                    </p>
                                    <p>
                                        Notice that the singletons' scope is the enclosing container.
                                        Different container instances will have different singleton instances.
                                    </p>
                                </li>
                                <li>app.register_proto( bean_name, bean_function )
                                    <p>
                                        Registers the bean as a template for creating beans, meaning that each time you request it,
                                        a different instance will be returned
                                    </p>
                                </li>
                            </ul>
                            <p>
                                In bean notation, you should pass a scope attribute with the value <code>app.PROTOTYPE</code> to use prototype scope.
                                The default scope is <code>app.SINGLETON</code>.
                            </p>
                        </section>
                        <section id="circular-dependencies">
                            <h1>Circular Dependencies</h1>
                            <p>
                                Since all dependencies are injected during creation of beans, not by setting properties,
                                there is no support for circular dependencies in require-bean just yet.
                            </p>
                        </section>
                        <section id="multiple-containers">
                            <h1>Multiple Containers</h1>
                            <pre>var requireBean = require('require-bean');

/*Creates a container named 'myapp'*/
var myApp = requireBean.container('myApp');

/*Creates a container named 'otherapp'*/
var otherApp = requireBean.container('otherApp');</pre>

                            <p>
                                <code>requireBean.container()</code> method is called to create containers.
                                Beans that are registered in one container will NOT be available in the other container instances.
                                If your app starts other apps, you should consider create separated container instances for each app.
                            </p>
                        </section>
                        <section id="interceptors">
                            <h1>Interceptors</h1>
                            <p>
                                In order to keep it's core minimal, <code>require-bean</code> implements a system of interceptors,
                                allowing third party code to hook into the bean resolution mechanism.
                            </p>
                            <p>
                                Features like <a href="#bean-notation">registering all beans of a directory</a> and the <a href="#asynchronous-beans">special dependency</a> <code>$return</code> are
                                implemented internally using interceptors.
                            </p>
                            <p>
                                An interceptor is easily created by extending a base <code>Interceptor</code> class, like the following:
                            </p>
                            <pre class="prettyprint">var requireBean = require('require-bean'),
    Interceptor = requireBean.Interceptor;

function MyCustomInterceptor(){
}

Interceptor(MyCustomInterceptor);

Interceptor.prototype.bind = function(container){
/* this code gets called right after you register the interceptor in a container; */
}

Interceptor.prototype.doRegisterPhase = function(beanDef){
/*
    Whenever a bean is registered into the container, it's definition object will be passed here.
    beanDef usually will be an object with the bean notation format.
    return true to indicate that other interceptors should run after yours. Return false to break the chain
*/
    return true;
}

Interceptor.prototype.doPreparePhase = function(bean, callback, next){
/*
    Whenever a bean enters Preparation Phase (see details below), this will be called.
    You must call next passing three arguments: an error, the received bean and the received callback.
    If an error argument is passed, the chain will end in your interceptor, otherwise it will continue
    until it ends the Preparation Phase.
*/
    next(null, bean, callback);
}

Interceptor.prototype.doResolvePhase = function(bean, callback, next){
/*
    Whenever a bean enters Resolve Phase (see details below), this will be called.
    You should call next like in doPreparePhase, to continue or break the chain.
*/
    next(null, bean, callback);
}

Interceptor.prototype.doInstantiationPhase = function(bean, callback, next){
/*
    Whenever a bean enters Instantiation Phase (see details below), this will be called.
    You should call next like in doPreparePhase, to continue or break the chain.
*/
    next(null, bean, callback);
}</pre>
                            <h3>Bean Resolution Phases</h3>
                            <p>
                                Interceptors' processing will be easier to follow if we understand the phases of beans resolutions, which are:
                            </p>
                            <ul>
                                <li>Prepare Phase
                                    <p>
                                        When the bean is selected to be resolved, it begins by calling it's Prepare Phase.
                                        This is the first step, and at this time, the interceptor's <code>doPreparePhase</code> method
                                        will be called, to give them a chance of doing some startup logic.

                                        If the Prepare Phase finishes successfully, the bean will move to Resolve Phase.
                                    </p>
                                </li>
                                <li>Resolve Phase
                                    <p>
                                        This is the time when the bean checks its dependencies.
                                        Right now, all the interceptors will have a chance of running their <code>doResolvePhase</code> method.
                                        If no interceptor breaks the chain, the bean finally resolve its dependencies.
                                        For each unresolved dependency it begins the resolution process to resolve them all.
                                        When all dependencies are resolved, the bean moves to the Instantiation Phase.
                                    </p>
                                </li>
                                <li>Instantiation Phase
                                    <p>
                                        Now the bean is ready to be instantiated, but once again, interceptors can hook it's behaviour.
                                        At this time, the interceptors will have a chance of running their <code>doInstantiationPhase</code> method.
                                        It is important that if any interceptor does the instantiation process by itself,
                                        that it sets the flag <code>bean.instantiated</code> to true, so it will know that it was instantiated
                                        during intercept hooks, thus not trying to create the bean object twice.
                                    </p>
                                </li>
                            </ul>
                            <p>Finally, to hook up the interceptor into our container, we use the <code>use</code> method, like that: </p>
                            <pre class="prettyprint">var app = require('require-bean').container('myapp');
app.use( new MyCustomInterceptor() );</pre>
                            <p>Out of the box, we provide a testing interceptor, that logs whenever a bean enters a resolution phase:</p>
                            <pre class="prettyprint">var middleware = require('require-bean').middleware;
app.use( middleware.debuggerInterceptor() );</pre>
                            <p>Also, it's important to say that you should call <code>use</code> before registering any beans into the container.</p>
                            <h3>Bean Object</h3>
                            <p>
                                The <code>bean</code> parameter that is passed to <code>doRegisterPhase</code>, <code>doResolvePhase</code> and
                                <code>doInstantiationPhase</code>, looks supports the following operations:
                            </p>
                            <pre class="prettyprint">/**********************************************************************
    Properties that should NOT be altered without a REALLY good reason
**********************************************************************/

bean.name;           // returns the name of the bean.
bean.dependencyList; // returns an object containing the dependencies.
bean.factory;        // returns the factory function to create the bean;


/**********************************************************************
    Method calls
**********************************************************************/
var dependencyList = bean.dependencyList;

// returns an object representing the next unresoved dependency of the bean.
var nextUnresolved = dependencyList.nextUnresolved();

// resolves the next unresolved dependency, by setting it to obj.
nextUnresolved.resolve( obj );

// applies a function passing the resolved dependencies as arguments. Returns what func returns.
dependencyList.apply( func );


/**********************************************************************
    Properties that can be altered
**********************************************************************/
bean.instantiated;   // If you instantiate the bean manually, this should be set to true.</pre>
                        </section>
                    </div>
                </div>
            </div>
        </div>

    </div>

    <!-- JavaScript -->
    <script src="https://google-code-prettify.googlecode.com/svn/loader/run_prettify.js"></script>
    <script src="https://code.jquery.com/jquery-1.10.2.min.js"></script>
    <script src="http://netdna.bootstrapcdn.com/bootstrap/3.1.1/js/bootstrap.min.js"></script>

    <!-- Custom JavaScript for the Menu Toggle -->
    <script>
    $("#menu-toggle").click(function(e) {
        e.preventDefault();
        $("#wrapper").toggleClass("active");
    });
    </script>
</body>

</html>
